{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let LazyViewport = /*#__PURE__*/(() => {\n  class LazyViewport {\n    // I initialize the lazy-viewport service.\n    constructor() {\n      // ---\n      // PRIVATE METHODS.\n      // ---\n      // I handle changes in the visibility for elements being tracked by the intersection\n      // observer.\n      // --\n      // CAUTION: Using fat-arrow binding for method.\n      this.handleIntersectionUpdate = entries => {\n        for (var entry of entries) {\n          var lazyTarget = this.targets.get(entry.target);\n          lazyTarget && lazyTarget.updateVisibility(entry.isIntersecting, entry.intersectionRatio);\n        }\n      };\n\n      this.observer = null; // The IntersectionObserver watches Elements. However, when an element visibility\n      // changes, we have to alert an Angular Directive instance. As such, we're going\n      // to keep a map of Elements-to-Directives. This way, when our observer callback\n      // is invoked, we'll be able to extract the appropriate Directive from the\n      // Element-based observer entries collection.\n\n      this.targets = new Map();\n    } // ---\n    // PUBLIC METHODS.\n    // ---\n    // I add the given LazyTarget implementation to the collection of objects being\n    // tracked by the IntersectionObserver.\n\n\n    addTarget(target) {\n      if (this.observer) {\n        this.targets.set(target.element, target);\n        this.observer.observe(target.element); // If we don't actually have an observer (lacking browser support), then we're\n        // going to punt on the feature for now and just immediately tell the target\n        // that it is visible on the page.\n      } else {\n        target.updateVisibility(true, 1.0);\n      }\n    } // I setup the IntersectionObserver with the given element as the root.\n\n\n    setup(element = null, offset = 0) {\n      // While the IntersectionObserver is supported in the modern browsers, it will\n      // never be added to Internet Explorer (IE) and is not in my version of Safari\n      // (at the time of this post). As such, we'll only use it if it's available.\n      // And, if it's not, we'll fall-back to non-lazy behaviors.\n      if (!window || window && !window['IntersectionObserver']) {\n        return;\n      }\n\n      this.observer = new IntersectionObserver(this.handleIntersectionUpdate, {\n        root: element,\n        rootMargin: `${offset}px`\n      });\n    } // I remove the given LazyTarget implementation from the collection of objects being\n    // tracked by the IntersectionObserver.\n\n\n    removeTarget(target) {\n      // If the IntersectionObserver isn't supported, we never started tracking the\n      // given target in the first place.\n      if (this.observer) {\n        this.targets.delete(target.element);\n        this.observer.unobserve(target.element);\n      }\n    } // I teardown this service instance.\n\n\n    teardown() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      }\n\n      this.targets.clear();\n      this.targets = null;\n    }\n\n  }\n\n  LazyViewport.ɵfac = function LazyViewport_Factory(t) {\n    return new (t || LazyViewport)();\n  };\n\n  LazyViewport.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: LazyViewport,\n    factory: LazyViewport.ɵfac\n  });\n  return LazyViewport;\n})();","map":null,"metadata":{},"sourceType":"module"}